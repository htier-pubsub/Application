import streamlit as st
import paho.mqtt.client as mqtt
import threading
import json
import time
from datetime import datetime
import queue
import os
import pickle
import requests
from pyModbusTCP.client import ModbusClient
from abc import ABC, abstractmethod

# Global lock for thread safety
message_lock = threading.Lock()

# File-based storage for cross-thread communication (Htier for all protocols)
MESSAGE_FILE = "universal_messages.pkl"
COUNTER_FILE = "message_counter.txt"

def save_message_to_file(message):
    """Save message to file for cross-thread access."""
    try:
        with message_lock:
            messages = []
            if os.path.exists(MESSAGE_FILE):
                with open(MESSAGE_FILE, 'rb') as f:
                    messages = pickle.load(f)
            
            messages.append(message)
            # Keep only last 100 messages
            if len(messages) > 100:
                messages = messages[-100:]
            
            with open(MESSAGE_FILE, 'wb') as f:
                pickle.dump(messages, f)
            
            print(f"üíæ SAVED: Message saved to file. Total in file: {len(messages)}")
    except Exception as e:
        print(f"‚ùå Error saving message to file: {e}")

def load_messages_from_file():
    """Load messages from file."""
    try:
        if os.path.exists(MESSAGE_FILE):
            with open(MESSAGE_FILE, 'rb') as f:
                return pickle.load(f)
        return []
    except Exception as e:
        print(f"‚ùå Error loading messages from file: {e}")
        return []

def increment_counter():
    """Increment message counter in file."""
    try:
        with message_lock:
            counter = 0
            if os.path.exists(COUNTER_FILE):
                with open(COUNTER_FILE, 'r') as f:
                    counter = int(f.read().strip())
            
            counter += 1
            with open(COUNTER_FILE, 'w') as f:
                f.write(str(counter))
            
            return counter
    except Exception as e:
        print(f"‚ùå Error updating counter: {e}")
        return 0

def get_counter():
    """Get current message counter from file."""
    try:
        if os.path.exists(COUNTER_FILE):
            with open(COUNTER_FILE, 'r') as f:
                return int(f.read().strip())
        return 0
    except Exception as e:
        return 0

# Initialize universal session state variables
if 'messages' not in st.session_state:
    st.session_state.messages = []

# Legacy MQTT functions removed - now handled by MQTTHandler class

def process_message_queue():
    """Load messages from file and update session state."""
    # Ensure messages list exists
    if 'messages' not in st.session_state:
        st.session_state.messages = []
    
    # Load messages from file
    file_messages = load_messages_from_file()
    file_counter = get_counter()
    
    # Update session state with file messages
    initial_count = len(st.session_state.messages)
    st.session_state.messages = file_messages
    current_count = len(st.session_state.messages)
    
    messages_processed = current_count - initial_count
    
    # Debug info
    #if file_counter > 0 or current_count > 0:
        #print(f"üìä STATS: File Counter: {file_counter}, File Messages: {len(file_messages)}, UI Display: {current_count}")
    
    return messages_processed

def get_filtered_messages(protocol_name):
    """Get messages filtered by current protocol."""
    all_messages = st.session_state.messages
    if not all_messages:
        return []
    
    # Filter messages by protocol
    filtered = [msg for msg in all_messages if msg.get('protocol', '').upper() == protocol_name.upper()]
    return filtered

# Legacy connection check removed - now handled by individual protocol handlers

# Abstract Protocol Handler Interface
class ProtocolHandler(ABC):
    """Abstract base class for all streaming protocol handlers."""
    
    def __init__(self, name):
        self.name = name
        self.status = "Disconnected"
        self.thread = None
        self.running = False
    
    @abstractmethod
    def connect(self, config) -> bool:
        """Connect to the data source."""
        pass
    
    @abstractmethod
    def disconnect(self) -> None:
        """Disconnect from the data source."""
        pass
    
    @abstractmethod
    def get_config_ui(self) -> dict:
        """Return Streamlit UI elements for configuration."""
        pass
    
    def save_message(self, message_data):
        """Save message using the universal file system."""
        save_message_to_file(message_data)
        increment_counter()

# MQTT Protocol Handler
class MQTTHandler(ProtocolHandler):
    def __init__(self):
        super().__init__("MQTT")
        self.client = None
        self.subscribed_topics = set()
    
    def connect(self, config):
        try:
            self.client = mqtt.Client(client_id=config.get('client_id'), protocol=mqtt.MQTTv311)
            self.client.on_connect = self._on_connect
            self.client.on_disconnect = self._on_disconnect
            self.client.on_message = self._on_message
            
            if config.get('username') and config.get('password'):
                self.client.username_pw_set(config['username'], config['password'])
            
            result = self.client.connect(config['host'], config['port'], config.get('keep_alive', 60))
            if result == 0:
                self.client.loop_start()
                self.status = "Connecting..."
                return True
            return False
        except Exception as e:
            print(f"‚ùå MQTT connection error: {e}")
            return False
    
    def disconnect(self):
        if self.client:
            self.client.loop_stop()
            self.client.disconnect()
            self.client = None
            self.status = "Disconnected"
            self.subscribed_topics.clear()
    
    def _on_connect(self, client, userdata, flags, rc):
        self.status = "Connected" if rc == 0 else f"Failed (code {rc})"
    
    def _on_disconnect(self, client, userdata, rc):
        self.status = "Disconnected"
    
    def _on_message(self, client, userdata, msg):
        try:
            topic = msg.topic
            payload = msg.payload.decode('utf-8')
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
            
            try:
                parsed_payload = json.loads(payload)
            except json.JSONDecodeError:
                parsed_payload = payload
            
            message_data = {
                'protocol': 'MQTT',
                'timestamp': timestamp,
                'source': topic,
                'data': parsed_payload,
                'metadata': {'qos': msg.qos, 'retain': msg.retain}
            }
            
            self.save_message(message_data)
            print(f"üì® MQTT: {topic} -> {payload}")
        except Exception as e:
            print(f"‚ùå MQTT message error: {e}")
    
    def subscribe(self, topic):
        if self.client and self.status == "Connected":
            result, _ = self.client.subscribe(topic)
            if result == mqtt.MQTT_ERR_SUCCESS:
                self.subscribed_topics.add(topic)
                return True
        return False
    
    def publish(self, topic, message):
        if self.client and self.status == "Connected":
            result = self.client.publish(topic, message)
            return result.rc == mqtt.MQTT_ERR_SUCCESS
        return False
    
    def get_config_ui(self):
        config = {}
        config['host'] = st.text_input("MQTT Broker Host", value="broker.emqx.io")
        config['port'] = st.number_input("Port", value=1883, min_value=1, max_value=65535)
        config['client_id'] = st.text_input("Client ID", value=f"mqtt_{int(time.time())}")
        config['username'] = st.text_input("Username (optional)")
        config['password'] = st.text_input("Password (optional)", type="password")
        config['keep_alive'] = st.number_input("Keep Alive (seconds)", value=60)
        return config

# HTTP/Rust Server Handler  
class HTTPHandler(ProtocolHandler):
    def __init__(self):
        super().__init__("HTTP/Rust Server")
        self.base_url = ""
        self.poll_interval = 5
        self.last_data = None
    
    def connect(self, config):
        self.base_url = f"http://{config['host']}:{config['port']}"
        self.poll_interval = config.get('poll_interval', 5)
        
        # Test connection
        if self._check_health():
            self.running = True
            self.thread = threading.Thread(target=self._polling_loop)
            self.thread.daemon = True
            self.thread.start()
            self.status = "Connected"
            return True
        return False
    
    def disconnect(self):
        self.running = False
        if self.thread:
            self.thread.join(timeout=2)
        self.status = "Disconnected"
    
    def _check_health(self):
        try:
            response = requests.get(f"{self.base_url}/health", timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def _polling_loop(self):
        while self.running:
            try:
                # Poll for data from the Rust server
                response = requests.get(f"{self.base_url}/data/python_message", timeout=5)
                if response.status_code == 200:
                    data = response.text
                    if data != self.last_data:  # Only process new data
                        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                        
                        # Parse the bridge script format: [array]_timestamp
                        try:
                            if '_' in data:
                                array_part, time_part = data.rsplit('_', 1)
                                # Try to parse the array part
                                if array_part.startswith('[') and array_part.endswith(']'):
                                    # Parse as array
                                    import ast
                                    parsed_array = ast.literal_eval(array_part)
                                    parsed_data = {
                                        'modbus_registers': parsed_array,
                                        'bridge_timestamp': time_part,
                                        'register_count': len(parsed_array) if isinstance(parsed_array, list) else 0
                                    }
                                else:
                                    parsed_data = {'raw_data': data, 'note': 'Could not parse as array'}
                            else:
                                parsed_data = {'raw_data': data}
                        except Exception as parse_error:
                            print(f"‚ö†Ô∏è HTTP parsing error: {parse_error}")
                            parsed_data = {'raw_data': data, 'parse_error': str(parse_error)}
                        
                        message_data = {
                            'protocol': 'HTTP',
                            'timestamp': timestamp,
                            'source': 'modbus_bridge_via_rust',
                            'data': parsed_data,
                            'metadata': {
                                'url': f"{self.base_url}/data/python_message",
                                'raw_response': data[:100] + '...' if len(data) > 100 else data
                            }
                        }
                        
                        self.save_message(message_data)
                        self.last_data = data
                        register_count = len(parsed_data.get('modbus_registers', []))
                        if 'modbus_registers' in parsed_data:
                            print(f"üåê HTTP: modbus_bridge -> {register_count} registers: {parsed_data['modbus_registers'][:5]}...")
                        else:
                            print(f"üåê HTTP: raw_data -> {data[:100]}")
                        print(f"üîç HTTP DEBUG: Full response: {data[:200]}")
                
                time.sleep(self.poll_interval)
            except Exception as e:
                print(f"‚ùå HTTP polling error: {e}")
                time.sleep(self.poll_interval)
    
    def get_config_ui(self):
        config = {}
        config['host'] = st.text_input("Rust Server Host", value="localhost")
        config['port'] = st.number_input("Rust Server Port", value=5000)
        config['poll_interval'] = st.number_input("Poll Interval (seconds)", value=2, min_value=1)
        st.info("üí° This connects to your Rust server that receives Modbus data from the bridge script.")
        return config

# Modbus Handler
class ModbusHandler(ProtocolHandler):
    def __init__(self):
        super().__init__("Modbus")
        self.client = None
        self.poll_interval = 2
        self.last_values = None
    
    def connect(self, config):
        try:
            self.client = ModbusClient(host=config['host'], port=config['port'])
            self.poll_interval = config.get('poll_interval', 2)
            
            if self.client.open():
                self.running = True
                self.thread = threading.Thread(target=self._polling_loop)
                self.thread.daemon = True
                self.thread.start()
                self.status = "Connected"
                return True
            return False
        except Exception as e:
            print(f"‚ùå Modbus connection error: {e}")
            return False
    
    def disconnect(self):
        self.running = False
        if self.thread:
            self.thread.join(timeout=2)
        if self.client:
            self.client.close()
        self.status = "Disconnected"
    
    def _polling_loop(self):
        while self.running:
            try:
                if self.client:  # Check if client exists
                    # Read holding registers (adjust address and count as needed)
                    values = self.client.read_holding_registers(0, 10)  # Read 10 registers from address 0
                    
                    if values and values != self.last_values:
                        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                        
                        message_data = {
                            'protocol': 'Modbus',
                            'timestamp': timestamp,
                            'source': 'holding_registers',
                            'data': values,
                            'metadata': {'address': 0, 'count': 10}
                        }
                        
                        self.save_message(message_data)
                        self.last_values = values
                        print(f"‚ö° Modbus: holding_registers -> {values}")
                else:
                    print("‚ùå Modbus client is None")
                    break
                
                time.sleep(self.poll_interval)
            except Exception as e:
                print(f"‚ùå Modbus polling error: {e}")
                time.sleep(self.poll_interval)
    
    def get_config_ui(self):
        config = {}
        config['host'] = st.text_input("Modbus Host", value="127.0.0.1")
        config['port'] = st.number_input("Modbus Port", value=12345)
        config['poll_interval'] = st.number_input("Poll Interval (seconds)", value=2, min_value=1)
        return config

# Initialize protocol handlers
if 'protocol_handlers' not in st.session_state:
    st.session_state.protocol_handlers = {
        'MQTT': MQTTHandler(),
        'HTTP': HTTPHandler(), 
        'Modbus': ModbusHandler()
    }

if 'active_protocol' not in st.session_state:
    st.session_state.active_protocol = 'MQTT'

# Streamlit UI
st.set_page_config(page_title="Htier Live Streaming", page_icon="üåê", layout="wide")

st.title("üåê Htier Live Streaming Hub")
st.caption("Connect to MQTT, HTTP/REST, or Modbus data sources")

# Process messages before displaying UI  
new_messages = process_message_queue()

# Force refresh if we got new messages
if new_messages > 0:
    print(f"üîÑ UI REFRESH: {new_messages} new messages processed, refreshing UI")
    st.rerun()

# Protocol selection
st.header("üîß Protocol Selection")

# Add helpful guidance
st.info("üí° **Quick Guide:** Use **HTTP** to see bridge script data via Rust server, or **Modbus** for direct TCP connection")

selected_protocol = st.selectbox(
    "Choose streaming protocol:",
    options=['MQTT', 'HTTP', 'Modbus'],
    index=['MQTT', 'HTTP', 'Modbus'].index(st.session_state.active_protocol),
    help="HTTP = Bridge script data via Rust server | Modbus = Direct TCP connection | MQTT = IoT messaging"
)

if selected_protocol != st.session_state.active_protocol:
    # Disconnect from current protocol
    current_handler = st.session_state.protocol_handlers[st.session_state.active_protocol]
    current_handler.disconnect()
    st.session_state.active_protocol = selected_protocol
    st.rerun()

# Get current protocol handler
current_handler = st.session_state.protocol_handlers[st.session_state.active_protocol]

# Create two columns for layout
col1, col2 = st.columns([1, 2])

with col1:
    st.header(f"üì° {current_handler.name} Configuration")
    
    # Get protocol-specific configuration UI
    with st.form("protocol_config"):
        config = current_handler.get_config_ui()
        
        col_connect, col_disconnect = st.columns(2)
        
        with col_connect:
            connect_clicked = st.form_submit_button("Connect", type="primary")
        
        with col_disconnect:
            disconnect_clicked = st.form_submit_button("Disconnect")
    
    # Handle connection/disconnection
    if connect_clicked:
        current_handler.disconnect()  # Disconnect first
        if current_handler.connect(config):
            st.success(f"Connecting to {current_handler.name}...")
        else:
            st.error(f"Failed to connect to {current_handler.name}")
    
    if disconnect_clicked:
        current_handler.disconnect()
        st.success("Disconnected successfully")
    
    # Display connection status
    status_color = "üü¢" if current_handler.status == "Connected" else "üî¥"
    st.write(f"**Status:** {status_color} {current_handler.status}")
    
    # Protocol-specific controls
    if current_handler.name == "MQTT" and current_handler.status == "Connected":
        st.markdown("---")
        st.subheader("üì° MQTT Controls")
        
        # Topic subscription
        with st.form("mqtt_topics"):
            topic = st.text_input("Topic", value="modtopic")
            col_sub, col_unsub, col_pub = st.columns(3)
            
            with col_sub:
                sub_clicked = st.form_submit_button("Subscribe")
            with col_unsub:
                unsub_clicked = st.form_submit_button("Unsubscribe") 
            with col_pub:
                pub_clicked = st.form_submit_button("Publish Test")
        
        if sub_clicked and topic:
            if current_handler.subscribe(topic):
                st.success(f"Subscribed to {topic}")
        
        if unsub_clicked and topic:
            st.info(f"Unsubscribed from {topic}")
        
        if pub_clicked and topic:
            test_message = '{"msg": "hello from Htier app"}'
            if current_handler.publish(topic, test_message):
                st.success(f"Published to {topic}")
        
        # Show subscribed topics
        if current_handler.subscribed_topics:
            st.write("**Active Subscriptions:**")
            for topic in current_handler.subscribed_topics:
                st.write(f"‚Ä¢ {topic}")
    
    # Protocol information
    st.markdown("---")
    st.subheader("üìã Protocol Info")
    
    if current_handler.name == "MQTT":
        st.write("**Protocol:** Message Queuing Telemetry Transport")
        st.write("**Use Case:** IoT device communication, pub/sub messaging")
        st.write("**Data Flow:** Subscribe to topics, receive real-time messages")
    elif current_handler.name == "HTTP/Rust Server":
        st.write("**Protocol:** HTTP polling from Rust server")
        st.write("**Use Case:** Get Modbus data via bridge script")
        st.write("**Data Flow:** Bridge script -> Rust server -> Streamlit app")
        st.write("**Expected Format:** `[register_array]_timestamp`")
        st.success("üí° Use this to see your bridge script's rich register data!")
    elif current_handler.name == "Modbus":
        st.write("**Protocol:** Modbus TCP direct connection")
        st.write("**Use Case:** Direct Modbus server reading")
        st.write("**Data Flow:** Read holding registers directly from Modbus TCP server")
        st.info("‚ÑπÔ∏è This reads directly from Modbus server, not bridge script data")

with col2:
    st.header("Live Messages")
    
    # Process any new messages from the queue (already done above)
    pass
    
    # Auto-refresh controls
    auto_refresh = st.checkbox("Auto-refresh messages", value=True)
    
    col_refresh, col_clear = st.columns(2)
    with col_refresh:
        if st.button("üîÑ Refresh"):
            st.rerun()
    
    with col_clear:
        if st.button("üóëÔ∏è Clear Messages"):
            st.session_state.messages = []
            st.rerun()
    
        # Debug info for message display
    file_counter = get_counter()
    file_messages = load_messages_from_file()
    
    # First get the filtered messages
    current_protocol = st.session_state.active_protocol
    if current_protocol == 'HTTP':
        protocol_filter = 'HTTP'
    else:
        protocol_filter = current_protocol
    
    # Show filter options
    col_filter1, col_filter2 = st.columns(2)
    with col_filter1:
        show_all = st.checkbox("Show all protocols", value=False)
    with col_filter2:
        if not show_all:
            st.write(f"**Showing:** {protocol_filter} messages only")
    
    # Get messages to display
    if show_all:
        messages_to_show = st.session_state.messages
        message_count = len(messages_to_show)
    else:
        messages_to_show = get_filtered_messages(protocol_filter)
        message_count = len(messages_to_show)
        total_count = len(st.session_state.messages)
        if total_count > message_count:
            st.info(f"Showing {message_count} {protocol_filter} messages (Total: {total_count} from all protocols)")
    
    with st.expander("üîß Debug Information", expanded=False):
        st.write(f"**File Counter:** {file_counter}")
        st.write(f"**File Messages:** {len(file_messages)}")
        st.write(f"**All Messages:** {len(st.session_state.messages)}")
        st.write(f"**Filtered Messages:** {len(messages_to_show)}")
        st.write(f"**Active Protocol:** {current_handler.name}")
        st.write(f"**Protocol Status:** {current_handler.status}")
        
        # Show protocol breakdown
        if st.session_state.messages:
            protocol_counts = {}
            for msg in st.session_state.messages:
                protocol = msg.get('protocol', 'Unknown')
                protocol_counts[protocol] = protocol_counts.get(protocol, 0) + 1
            st.write("**Messages by Protocol:**")
            for protocol, count in protocol_counts.items():
                st.write(f"  - {protocol}: {count}")
        
        # Show latest message info and raw data for debugging
        if messages_to_show:
            latest_msg = messages_to_show[-1]
            st.write(f"**Latest Filtered Message:** {latest_msg.get('timestamp', 'Unknown')} from {latest_msg.get('source', 'Unknown')}")
            
            # Show raw data structure for HTTP debugging
            if latest_msg.get('protocol') == 'HTTP':
                st.write("**HTTP Message Structure:**")
                st.json(latest_msg)
        elif st.session_state.messages:
            latest_msg = st.session_state.messages[-1]
            st.write(f"**Latest Any Message:** {latest_msg.get('timestamp', 'Unknown')} from {latest_msg.get('source', 'Unknown')}")
        else:
            st.write("**Latest Message:** None")
    
    # Messages are already filtered above
    
    if message_count > 0:
        st.success(f"üéâ **{message_count} Messages Received and Displayed!**")
        
        # Show messages in reverse order (newest first)
        for i, message in enumerate(reversed(messages_to_show)):
            # Htier message format
            protocol = message.get('protocol', 'Unknown')
            source = message.get('source', 'Unknown')
            timestamp = message.get('timestamp', 'Unknown')
            
            # Protocol-specific icons
            icon = "üì®" if protocol == "MQTT" else "üåê" if protocol == "HTTP" else "‚ö°" if protocol == "Modbus" else "üì°"
            
            with st.expander(f"{icon} {protocol}: {source} - {timestamp}", expanded=(i < 3)):
                col_msg1, col_msg2 = st.columns([3, 1])
                
                with col_msg1:
                    st.write("**Protocol:**", protocol)
                    st.write("**Source:**", source)
                    st.write("**Timestamp:**", timestamp)
                    st.write("**Data:**")
                    
                    # Display data based on type
                    data_content = message.get('data')
                    if isinstance(data_content, dict):
                        # Special handling for HTTP modbus bridge data
                        if protocol == "HTTP" and 'modbus_registers' in data_content:
                            registers = data_content['modbus_registers']
                            st.write(f"**Modbus Registers ({len(registers)} values):**")
                            # Display registers in a more readable format
                            if len(registers) > 10:
                                st.write(f"First 10: {registers[:10]}")
                                st.write(f"Last 10: {registers[-10:]}")
                                with st.expander("View all register values"):
                                    st.json(registers)
                            else:
                                st.json(registers)
                            
                            # Show other fields too
                            if 'bridge_timestamp' in data_content:
                                st.write(f"**Bridge Timestamp:** {data_content['bridge_timestamp']}")
                        else:
                            st.json(data_content)
                    elif isinstance(data_content, list):
                        st.write(f"Array with {len(data_content)} elements:")
                        st.json(data_content)
                    else:
                        st.code(str(data_content or 'No data'))
                
                with col_msg2:
                    st.write("**Metadata:**")
                    metadata = message.get('metadata', {})
                    if metadata:
                        for key, value in metadata.items():
                            st.write(f"**{key.title()}:** {value}")
                    else:
                        st.write("None")
    else:
        total_messages = len(st.session_state.messages)
        if total_messages > 0 and not show_all:
            st.info(f"No {protocol_filter} messages yet. {total_messages} messages from other protocols. Check 'Show all protocols' to see them.")
        else:
            if current_handler.name == "MQTT":
                st.info("No messages received yet. Connect and subscribe to topics to start receiving messages.")
            elif current_handler.name == "HTTP/Rust Server": 
                st.info("No data received yet. Connect to start polling the Rust server for updates.")
            elif current_handler.name == "Modbus":
                st.info("No register data received yet. Connect to start reading Modbus holding registers.")
        
        # Show file status for troubleshooting
        file_counter = get_counter()
        file_messages = load_messages_from_file()
        
        if file_counter > 0:
            try:
                st.warning(f"‚ö†Ô∏è {file_counter} total messages received. Showing {len(messages_to_show)} {protocol_filter} messages.")
                if not show_all:
                    st.info("Enable 'Show all protocols' to see messages from other protocols.")
            except:
                st.warning(f"‚ö†Ô∏è {file_counter} total messages received.")
        
        if len(file_messages) > len(st.session_state.messages):
            st.warning(f"‚ö†Ô∏è {len(file_messages)} messages in file but {len(st.session_state.messages)} in session. Processing...")
            # Force process again
            process_message_queue()
    
    # Auto-refresh functionality - refresh every 3 seconds when auto-refresh is enabled
    if auto_refresh:
        time.sleep(3)
        st.rerun()

# Footer
st.markdown("---")
st.markdown("üí° **Htier Streaming Tips:**")

if current_handler.name == "MQTT":
    st.markdown("- Use topics like `test/topic`, `sensor/temperature`, or `device/status`")
    st.markdown("- QoS 0 = at most once, QoS 1 = at least once, QoS 2 = exactly once")
elif current_handler.name == "HTTP/Rust Server":
    st.markdown("- Make sure your Rust server is running on localhost:5000")
    st.markdown("- Data is polled from `/data/python_message` endpoint")
    st.markdown("- Only new/changed data triggers message updates")
elif current_handler.name == "Modbus":
    st.markdown("- Connect to Modbus TCP server (default: 127.0.0.1:12345)")
    st.markdown("- Reads holding registers from address 0")
    st.markdown("- Only changed register values trigger updates")

st.markdown("- Enable auto-refresh to see live messages")
st.markdown("- All protocols use the same Htier message display format")
